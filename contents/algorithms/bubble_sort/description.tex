\subsection{Bubble Sort}
\subsubsection{Description}

%% DESCRIPTION
Bubble Sort is a comparison-based sorting algorithm that repeatedly compares adjacent elements and swaps them if they are out of order, moving one element at a time, until the list is sorted. It iterates through the array multiple times, allowing smaller elements to “bubble” to the beginning of the list, while larger elements sink to the end of the list with each pass.

Bubble Sort is considered as the simplest sorting algorithm, characterized by a straightforward and easy-to-understand algorithm. However, it is inefficient in large lists, having a time complexity that grows quadratically as the size of the input increases.

When sorting the elements in ascending order, Bubble Sort begins from the first index, comparing the first and second elements. If the first element is greater than the second element, they are swapped. This process goes on until a pass with no exchanges is made.

%% PSEUDOCODE
\subsubsection{Pseudocode}
Given an array $(Arr)$ of numbers with size $n$, accessing the elements for $Arr(i_0, i_1, i_2,\dots, i_{n-1})$ we can perform the bubble sort algorithm:

\begin{algorithm} [H]
    \caption{Bubble Sort (Ascending Order)}
    \begin{algorithmic}
    \State{} $n \gets \text{length}(Arr)$
    \For{$i \gets 0$ \textbf{to} $n - 1$}
        \For{$j \gets 0$ \textbf{to} $n - i - 2$}
            \If{$Arr[j] > Arr[j+1]$}
                \State{} swap $Arr[j]$ and $Arr[j+1]$
            \EndIf{}
        \EndFor{}
    \EndFor{}
\end{algorithmic}
\end{algorithm}

%% PSEUDOCODE DESCRIPTION
Inside the function, the algorithm employs two nested for loops to traverse the list multiple times. The outer loop is responsible for controlling the number of passes made over the array. For a list of n elements, Bubble Sort requires n-1 passes to ensure that all elements are sorted in the correct order. Each pass moves the next largest unsorted element to its correct position at the end of the array.

Nested within the outer loop is the inner loop, which handles the comparison of adjacent elements. During each iteration of the inner loop, the algorithm compares each pair of adjacent values. The range of the inner loop decreases with every outer loop iteration, as the largest values are already sorted and pushed to the end of the list.

The defining logic lies in the if statement inside the inner loop, which is a conditional check whether the current element is greater than the element that follows it. If this condition is true, a swap operation is performed to place the smaller element before the larger one. This swap is usually implemented with a temporary variable to ensure that no data is lost during the exchange.
